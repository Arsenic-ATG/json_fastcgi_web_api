C++ Header-\/only event driven communication between j\+Query in a web-\/browser via nginx.

This was developed because of a lack of a lightweight j\+Query to C++ communication. It\textquotesingle{}s a small helper which can easily be included in any C++ application which needs to talk to a web page where realtime data needs to be exchanged.

\hypertarget{md_README_autotoc_md1}{}\doxysubsection{Prerequisites}\label{md_README_autotoc_md1}

\begin{DoxyCode}{0}
\DoxyCodeLine{apt-\/get install libfcgi-\/dev}
\DoxyCodeLine{apt-\/get install libcurl4-\/openssl-\/dev}
\end{DoxyCode}
\hypertarget{md_README_autotoc_md2}{}\doxysubsection{Howto}\label{md_README_autotoc_md2}
The only file you need is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{json\_fastcgi\_web\_api.h}
\end{DoxyCode}


Copy this header file into your project, include it and then overload the abstract callbacks in the class.\hypertarget{md_README_autotoc_md3}{}\doxysubsubsection{Implement the G\+E\+T callback}\label{md_README_autotoc_md3}
This is the callback which sends J\+S\+ON to the website\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class GETCallback \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{        /**}
\DoxyCodeLine{         * Needs to return the payload data sent to the web browser.}
\DoxyCodeLine{         * Use the JSON generator class or an external json generator.}
\DoxyCodeLine{         **/}
\DoxyCodeLine{        virtual std::string getJSONString() = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


Overload {\ttfamily get\+J\+S\+O\+N\+String()} and return J\+S\+ON. You can use the class {\ttfamily J\+S\+O\+N\+Generator} to generate the J\+S\+ON data\+: Use the {\ttfamily add} methods to add key/value pairs and then get the json with the method {\ttfamily get\+J\+S\+O\+N()}.\hypertarget{md_README_autotoc_md4}{}\doxysubsubsection{Implement the P\+O\+S\+T callback (optional)}\label{md_README_autotoc_md4}
This handler receives the J\+S\+ON from j\+Query P\+O\+ST command from the website for example a button press. Implement the callback\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{class POSTCallback \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{        /**}
\DoxyCodeLine{         * Receives the data from the web browser in JSON format.}
\DoxyCodeLine{         * Use postDecoder() to decode the JSON or use an external}
\DoxyCodeLine{         * library.}
\DoxyCodeLine{         **/}
\DoxyCodeLine{        virtual void postString(std::string arg) = 0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


Overload {\ttfamily post\+String(std\+::string arg)} with a function which decodes the received P\+O\+ST data. You can use {\ttfamily post\+Decoder(std\+::string s)} which returns a {\ttfamily std\+::map} of key/value pairs.\hypertarget{md_README_autotoc_md5}{}\doxysubsubsection{Start the communication}\label{md_README_autotoc_md5}
The constructor takes as arguments the G\+ET callback, the P\+O\+ST callback and the path to the fast\+C\+GI socket. As soon as the constructor is instantiated the communication starts.


\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{  * Constructor which inits it and starts the main thread.}
\DoxyCodeLine{  * Provide an instance of the callback handler which provides the}
\DoxyCodeLine{  * payload data in return. The optional socketpath variable}
\DoxyCodeLine{  * can be set to another path for the socket which talks to the}
\DoxyCodeLine{  * webserver. postCallback is the callback which returns}
\DoxyCodeLine{  * received json packets as a map.}
\DoxyCodeLine{  **/}
\DoxyCodeLine{ JSONCGIHandler(GETCallback* argGetCallback,}
\DoxyCodeLine{                POSTCallback* argPostCallback = nullptr,}
\DoxyCodeLine{                const char socketpath[] = "/tmp/fastcgisocket");}
\end{DoxyCode}
\hypertarget{md_README_autotoc_md6}{}\doxysubsubsection{Stop the communication}\label{md_README_autotoc_md6}
This is done by deleting the instance.\hypertarget{md_README_autotoc_md7}{}\doxysubsection{Example code}\label{md_README_autotoc_md7}
The {\ttfamily demo\+\_\+sensor\+\_\+server} fakes a temperature sensor and this is plotted on the screen. The nginx config file and the website are in the {\ttfamily website} directory.

Start {\ttfamily demo\+\_\+sensor\+\_\+server} in the background with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{nohup ./demo\_sensor\_server \&}
\end{DoxyCode}


which creates a socket under {\ttfamily /tmp/sensorsocket} to communicate with the fastcgi server.\hypertarget{md_README_autotoc_md8}{}\doxysubsubsection{Configuring the nginx for Fast\+C\+GI}\label{md_README_autotoc_md8}

\begin{DoxyEnumerate}
\item copy the the nginx config file {\ttfamily website/nginx-\/sites-\/enabled-\/default} to your nginx config directory {\ttfamily /etc/nginx/sites-\/enabled/default}.
\item copy {\ttfamily website/fakesensor.\+html} to {\ttfamily /var/www/html}.
\end{DoxyEnumerate}

Then point your web-\/browser to {\ttfamily fakesensor.\+html} on your website. You should see a fake temperatue reading on the screen and a plot with dygraph. The J\+S\+ON packets can be viewed by appending {\ttfamily /sensor/} to the server U\+RL.

The script sends also a J\+S\+ON packet to the demo server which requests to clamp the temperature to 20C and prints out a string to stderr.

 